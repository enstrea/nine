## 特殊分隔符解码器

将特殊分隔符作为消息的结束标志，接收方通过这个特殊符号将接收到的数据包拆分开。

```go
// 服务端代码
func main() {
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		println(fmt.Sprintf("listen err: %s", err))
		return
	}
	for {
		conn, err := listen.Accept()
		if err != nil {
			println(fmt.Sprintf("accept err: %s", err))
			return
		}
		go handleConn(conn)
	}
}

func handleConn(c net.Conn)  {
	defer c.Close()

	var last []byte	// 上次解析后剩余字符
	for {
		buf := make([]byte, 1024)
		n, err := c.Read(buf)
		if err != nil {
			println(fmt.Sprintf("read err: %s", err))
			return
		}
		messages, sur := splitByte(last, buf[:n])
		last = sur
		for _, message := range messages {
			println(fmt.Sprintf("receive: %s", message))
		}
		time.Sleep(time.Second)
	}
}

func splitByte(last, buf []byte) ([][]byte, []byte) {
	// $ 作为分隔符
	bs := strings.Split(string(buf), "$")
	// 最后一个字符如果是分割符，要剪掉
	idx := strings.LastIndexByte(string(buf), '$')
	if idx == len(buf)-1 {
		bs = bs[:len(bs)-1]
	}

	var res = make([][]byte, 0)
	for i, b := range bs {
		if i == 0 && len(last) > 0 {
			res = append(res, append(last, []byte(b)...))
			last = nil
		} else {
			res = append(res, []byte(b))
		}
	}
	// 剩余字符
	if idx < len(buf)-1 {
		last = append(last, buf[idx+1:]...)
	}
	return res, last
}
```



```go
// 客户端代码
func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:9999")
	if err != nil {
		println(fmt.Sprintf("%s", err))
		return
	}

	for i := 0; i < 10; i++ {
		writeTo(conn, "abcdefg$")
	}
	_ = conn.Close()
}

func writeTo(c net.Conn, msg string)  {
	_, _ = c.Write([]byte(msg))
}
```





## 定长解码器

每次发送固定长度的数据包，接收方累计读取固定长度后，就认为读取到了完整的消息。

```go
// 服务端代码
func main() {
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		println(fmt.Sprintf("listen err: %s", err))
		return
	}
	for {
		conn, err := listen.Accept()
		if err != nil {
			println(fmt.Sprintf("accept err: %s", err))
			return
		}
		go handleConn(conn)
	}
}

func handleConn(c net.Conn)  {
	defer c.Close()

	for {
		buf := make([]byte, 4)
		_, err := io.ReadFull(c, buf)
		if err != nil {
			println(fmt.Sprintf("read err: %s", err))
			return
		}
		println(fmt.Sprintf("receive: %s", string(buf)))
	}
}
```



```go
// 客户端代码
func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:9999")
	if err != nil {
		println(fmt.Sprintf("%s", err))
		return
	}
	
	for i := 0; i < 10; i++ {
		_, _ = conn.Write([]byte("abcd"))
	}

	_ = conn.Close()
}
```



## 自定义长度解码器

在消息头中定义长度字段，来标识消息的总长度。

```go
// 服务端代码
func main() {
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		println(fmt.Sprintf("listen err: %s", err))
		return
	}
	for {
		conn, err := listen.Accept()
		if err != nil {
			println(fmt.Sprintf("accept err: %s", err))
			return
		}
		go handleConn(conn)
	}
}

func handleConn(c net.Conn)  {
	defer c.Close()

	for {
		msg, err := readFrom(c)
		if err != nil {
			println(err.Error())
			return
		}
		println(fmt.Sprintf("receive: %s", msg))
	}
}

func readFrom(c net.Conn) (string, error) {
	// 读取消息长度
	buf := make([]byte, 4)
	_, err := io.ReadFull(c, buf)
	if err != nil {
		return "", fmt.Errorf("read msg length err: %s", err)
	}

	// 读取消息内容
	length := binary.BigEndian.Uint32(buf)
	msgBuf := make([]byte, length)
	_, err = io.ReadFull(c, msgBuf)
	if err != nil {
		return "", fmt.Errorf("read msg err: %s", err)
	}
	return string(msgBuf), nil
}
```



```go
// 客户端代码
func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:9999")
	if err != nil {
		println(fmt.Sprintf("%s", err))
		return
	}

	for i := 0; i < 10; i++ {
		writeTo(conn, "abcdefg")
	}
	_ = conn.Close()
}

func writeTo(c net.Conn, msg string)  {
	// 消息长度
	length := uint32(len(msg))
	lengthByte := make([]byte, 4)
	binary.BigEndian.PutUint32(lengthByte, length)

	_, _ = c.Write(lengthByte)
	_, _ = c.Write([]byte(msg))
}
```



## goim协议解码器

```go
// 服务端代码
func main() {
	listen, err := net.Listen("tcp", ":9999")
	if err != nil {
		println(fmt.Sprintf("listen err: %s", err))
		return
	}

	for {
		conn, err := listen.Accept()
		if err != nil {
			println(fmt.Sprintf("accept err: %s", err))
			return
		}

		go handleConn(conn)
	}
}

func handleConn(conn net.Conn)  {
	defer conn.Close()

	for {
		rd := bufio.NewReader(conn)

		proto := &Proto{}
		if err := tcpReadProto(rd, proto); err != nil {
			println(fmt.Sprintf("receive err: %s", err))
			return
		}
		println(fmt.Sprintf("receive proto: %+v", proto))
		println(fmt.Sprintf("body: %s", string(proto.Body)))
	}
}

func tcpReadProto(rd *bufio.Reader, proto *Proto) (err error) {
	var (
		packLen   int32
		headerLen int16
	)
	// read
	if err = binary.Read(rd, binary.BigEndian, &packLen); err != nil {
		return
	}
	if err = binary.Read(rd, binary.BigEndian, &headerLen); err != nil {
		return
	}
	if err = binary.Read(rd, binary.BigEndian, &proto.Ver); err != nil {
		return
	}
	if err = binary.Read(rd, binary.BigEndian, &proto.Operation); err != nil {
		return
	}
	if err = binary.Read(rd, binary.BigEndian, &proto.Seq); err != nil {
		return
	}
	var (
		n, t    int
		bodyLen = int(packLen - int32(headerLen))
	)
	if bodyLen > 0 {
		proto.Body = make([]byte, bodyLen)
		for {
			if t, err = rd.Read(proto.Body[n:]); err != nil {
				return
			}
			if n += t; n == bodyLen {
				break
			}
		}
	} else {
		proto.Body = nil
	}
	return
}

// Proto proto.
type Proto struct {
	PackLen   int32  // package length
	HeaderLen int16  // header length
	Ver       int16  // protocol version
	Operation int32  // operation for request
	Seq       int32  // sequence number chosen by client
	Body      []byte // body
}
```



```go
// 客户端代码
const (
	rawHeaderLen = uint16(16)
)

func main() {
	conn, err := net.Dial("tcp", "127.0.0.1:9999")
	if err != nil {
		println(fmt.Sprintf("net dial err: %s", err))
		return
	}

	for i := int32(0); i < 10; i++ {
		wr := bufio.NewWriter(conn)
		proto := &Proto{
			Ver:       1,
			Operation: 0,
			Seq:       i,
			Body:      []byte("hello world"),
		}
		if err := tcpWriteProto(wr, proto); err != nil {
			println(fmt.Sprintf("write proto err: %s", err))
			return
		}
		time.Sleep(time.Second)
	}
	_ = conn.Close()
}

func tcpWriteProto(wr *bufio.Writer, proto *Proto) (err error) {
	// write
	if err = binary.Write(wr, binary.BigEndian, uint32(rawHeaderLen)+uint32(len(proto.Body))); err != nil {
		return
	}
	if err = binary.Write(wr, binary.BigEndian, rawHeaderLen); err != nil {
		return
	}
	if err = binary.Write(wr, binary.BigEndian, proto.Ver); err != nil {
		return
	}
	if err = binary.Write(wr, binary.BigEndian, proto.Operation); err != nil {
		return
	}
	if err = binary.Write(wr, binary.BigEndian, proto.Seq); err != nil {
		return
	}
	if proto.Body != nil {
		if err = binary.Write(wr, binary.BigEndian, proto.Body); err != nil {
			return
		}
	}
	err = wr.Flush()
	return
}

// Proto proto.
type Proto struct {
	PackLen   int32  // package length
	HeaderLen int16  // header length
	Ver       int16  // protocol version
	Operation int32  // operation for request
	Seq       int32  // sequence number chosen by client
	Body      []byte // body
}
```

